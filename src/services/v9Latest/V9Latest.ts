// This file was generated by liblab | https://liblab.com/

import BaseService from '../../BaseService';

import { ScoreFluencySpanishResponse } from './models/ScoreFluencySpanishResponse';
import { ScoreFluencySpanishRequest } from './models/ScoreFluencySpanishRequest';
import { ScoreAPhonemeListResponse } from './models/ScoreAPhonemeListResponse';
import { ScoreAPhonemeListRequest } from './models/ScoreAPhonemeListRequest';
import { ValidateTextResponse } from './models/ValidateTextResponse';
import { ValidateTextRequest } from './models/ValidateTextRequest';
import { PteAnswerQuestionResponse } from './models/PteAnswerQuestionResponse';
import { PteAnswerQuestionRequest } from './models/PteAnswerQuestionRequest';
import { GetGrammarVocabCoherenceFeedbackMetricsResponse } from './models/GetGrammarVocabCoherenceFeedbackMetricsResponse';
import { GetGrammarVocabCoherenceFeedbackMetricsRequest } from './models/GetGrammarVocabCoherenceFeedbackMetricsRequest';

import { serializeQuery } from '../../http/QuerySerializer';

export class V9LatestService extends BaseService {
  /**
   * @summary Score Fluency - Spanish
   * @description Score Fluency - Spanish

   * @param optionalParams - Optional parameters
   * @param optionalParams.key - API key issued by Speechace.
   * @param optionalParams.dialect - The dialect to use for scoring. Supported values are: en-us, en-gb, fr-fr, fr-ca
   * @returns {Promise<ScoreFluencySpanishResponse>} - The promise with the result
   */
  async scoreFluencySpanish(
    input: ScoreFluencySpanishRequest,
    optionalParams: { key?: string; dialect?: string } = {},
  ): Promise<ScoreFluencySpanishResponse> {
    const { key, dialect } = optionalParams;

    const queryParams: string[] = [];
    const headers: { [key: string]: string } = { 'Content-Type': 'multipart/form-data' };
    if (key) {
      queryParams.push(serializeQuery('form', true, 'key', key));
    }
    if (dialect) {
      queryParams.push(serializeQuery('form', true, 'dialect', dialect));
    }
    const urlEndpoint = '/api/scoring/text/v9/json';
    const urlParams = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';
    const finalUrl = encodeURI(`${this.baseUrl + urlEndpoint}${urlParams}`);
    const formInput = V9LatestService.formData(input);
    const response: any = await this.httpClient.post(
      finalUrl,
      formInput,
      {
        ...headers,
      },
      true,
    );
    const responseModel = response.data as ScoreFluencySpanishResponse;
    return responseModel;
  }

  /**
   * @summary Score a Phoneme list
   * @description **In this example we score the term:**

"gotcha" /g/ao1/ch/ah0

Since **gotcha** is an american vernacular and not a valid dictionary word we use the phoneme list API to score it.

The phoneme list uses a different url endpoint and expects the list of phonemes in [Arpabet notation](https://en.wikipedia.org/wiki/Arpabet).

Note that we specify phoneme stress as 0,1,2 per Arpabet notation. This API allows you to score any word or sentence that can phonetically expressed in Arpabet.

   * @param optionalParams - Optional parameters
   * @param optionalParams.key - API key issued by Speechace.
   * @param optionalParams.userId - Optional: A unique anonymized identifier for the end-user who spoke the audio.
   * @param optionalParams.dialect - The dialect to use for scoring. Supported values are "en-us" (US English) and "en-gb" (UK English).
   * @returns {Promise<ScoreAPhonemeListResponse>} - The promise with the result
   */
  async scoreAPhonemeList(
    input: ScoreAPhonemeListRequest,
    optionalParams: { key?: string; userId?: string; dialect?: string } = {},
  ): Promise<ScoreAPhonemeListResponse> {
    const { key, userId, dialect } = optionalParams;

    const queryParams: string[] = [];
    const headers: { [key: string]: string } = { 'Content-Type': 'multipart/form-data' };
    if (key) {
      queryParams.push(serializeQuery('form', true, 'key', key));
    }
    if (userId) {
      queryParams.push(serializeQuery('form', true, 'user_id', userId));
    }
    if (dialect) {
      queryParams.push(serializeQuery('form', true, 'dialect', dialect));
    }
    const urlEndpoint = '/api/scoring/phone_list/v9/json';
    const urlParams = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';
    const finalUrl = encodeURI(`${this.baseUrl + urlEndpoint}${urlParams}`);
    const formInput = V9LatestService.formData(input);
    const response: any = await this.httpClient.post(
      finalUrl,
      formInput,
      {
        ...headers,
      },
      true,
    );
    const responseModel = response.data as ScoreAPhonemeListResponse;
    return responseModel;
  }

  /**
   * @summary Validate Text
   * @description In this example we validate whether all the words in the text exist in the Speechace lexicon. This API allows you to quickly check whether authored content will be able to be scored with Speechace. This is useful to use at the time of text authoring to avoid errors later on.

Out of lexicon terms can be reported to [support@speechace.com](mailto:support@speechace.com) for inclusion. Or you can see the phoneme list API as an alternative.

You may also opt let Speechace API [automatically handle unknown words](https://docs.speechace.com/#2f59fc09-d3ef-410c-b9e8-ee91dddc0eec) by finding the most likely phonetic mapping for the term.

   * @param optionalParams - Optional parameters
   * @param optionalParams.key - API key issued by Speechace.
   * @param optionalParams.text - A sentence or sequence of words to validate.
   * @param optionalParams.dialect - The dialect to use for validation. Default is "en-us". Supported values are "en-us" (US English) and "en-gb" (UK English).
   * @returns {Promise<ValidateTextResponse>} - The promise with the result
   */
  async validateText(
    input: ValidateTextRequest,
    optionalParams: { key?: string; text?: string; dialect?: string } = {},
  ): Promise<ValidateTextResponse> {
    const { key, text, dialect } = optionalParams;

    const queryParams: string[] = [];
    const headers: { [key: string]: string } = { 'Content-Type': 'multipart/form-data' };
    if (key) {
      queryParams.push(serializeQuery('form', true, 'key', key));
    }
    if (text) {
      queryParams.push(serializeQuery('form', true, 'text', text));
    }
    if (dialect) {
      queryParams.push(serializeQuery('form', true, 'dialect', dialect));
    }
    const urlEndpoint = '/api/validating/text/v9/json';
    const urlParams = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';
    const finalUrl = encodeURI(`${this.baseUrl + urlEndpoint}${urlParams}`);
    const formInput = V9LatestService.formData(input);
    const response: any = await this.httpClient.post(
      finalUrl,
      formInput,
      {
        ...headers,
      },
      true,
    );
    const responseModel = response.data as ValidateTextResponse;
    return responseModel;
  }

  /**
   * @summary PTE Answer Question
   * @description PTE Answer Question

   * @param optionalParams - Optional parameters
   * @param optionalParams.key - API key issued by Speechace
   * @param optionalParams.taskType - The task_type to score. Supported types are: describe-image, retell-lecture, answer-question.
   * @param optionalParams.dialect - The dialect to use for scoring. Supported values are: en-us, en-gb, fr-fr, fr-ca, es-es, es-mx.
   * @returns {Promise<PteAnswerQuestionResponse>} - The promise with the result
   */
  async pteAnswerQuestion(
    input: PteAnswerQuestionRequest,
    optionalParams: { key?: string; taskType?: string; dialect?: string } = {},
  ): Promise<PteAnswerQuestionResponse> {
    const { key, taskType, dialect } = optionalParams;

    const queryParams: string[] = [];
    const headers: { [key: string]: string } = { 'Content-Type': 'multipart/form-data' };
    if (key) {
      queryParams.push(serializeQuery('form', true, 'key', key));
    }
    if (taskType) {
      queryParams.push(serializeQuery('form', true, 'task_type', taskType));
    }
    if (dialect) {
      queryParams.push(serializeQuery('form', true, 'dialect', dialect));
    }
    const urlEndpoint = '/api/scoring/task/v9/json';
    const urlParams = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';
    const finalUrl = encodeURI(`${this.baseUrl + urlEndpoint}${urlParams}`);
    const formInput = V9LatestService.formData(input);
    const response: any = await this.httpClient.post(
      finalUrl,
      formInput,
      {
        ...headers,
      },
      true,
    );
    const responseModel = response.data as PteAnswerQuestionResponse;
    return responseModel;
  }

  /**
   * @summary Get Grammar, Vocab, Coherence feedback metrics
   * @description **In this Spontaneous Speech Scoring example, we obtain and present feedback metrics for Grammar, Vocabulary, Coherence.**

Feedback metrics help the learner identify specific areas of weaknesses within each skill and provide score explainability. For example, a low grammar score could be due to accuracy or range, or simply because the response was too short to showcase sufficient grammatical mastery. The feedback indices provide insight into the reasoning behind the score and direct the learner on how to improve their next attempt.

To obtain the feedback metrics we add the body parameter `include_ielts_feedback=1` to the request.

### Feedbck Indices:

In the API result JSON the following fields are returned within the `speech_score.grammar`, `speech_score.vocab, speech_score.coherence` nodes. Each index has 3 sub-elements:

- **score:** on a scale of 1 to 10
- **level:** an interpretation of the score as low/mid/high
- **message:** a feedback message if the score is low.
    

| **Index** | **Description** |
| --- | --- |
| grammar.overall_metrics.length | The sufficiency of the response length in words to demonstrate the necessary grammatical range. |
| grammar.overall_metrics.lexical_diversity | The degree of variation in syntactic structures such as diversity in verbs, adjectives and adverbial modifiers. |
| grammar.overall_metrics.grammatical_accuracy | The degree of grammatical inaccuracies in the response. A list of grammatical errors with suggested replacements is returned in the `grammar.errors` node when this index is low. |
| grammar.overall_metrics.grammatical_range | The degree of grammatical range demonstrated in the response. This score is further broken down into 4 additional sub-indices:  \- noun_phrase_variation  \- noun_phrase_complexity  \- verb_construction_variation  \- adverb_modifier_variation |
| grammar.overall_metrics.grammatical_range.noun_phrase_variation | The degree of variation in structure of noun phrases such as the number and types of modifiers used in the response. |
| grammar.overall_metrics.grammatical_range.noun_phrase_complexity | The degree of complexity of noun phrases such as the richness of adjectives, relative clauses, prepositional phrases, nonfinite elements, determiners, and demonstratives used in the response. |
| grammar.overall.metrics.grammatical_range.verb_construction_variation | The degree of variation in verbal structures such as the number and types of verb structural elements used in the response. |
| grammar.overall.metrics.grammatical_range.adverb_modifier_variation | The degree of variation in types of adverbs or adverb phrases to modify clauses, verbs, and adjectives used in the response. |
| vocab.overall_metrics.lexical_diversity | The degree of word diversity in the response. |
| vocab.overall_metrics.word_sophistication | The degree of use of advanced, less common vocabulary in the response. |
| vocab.overall_metrics.word_specificity | The degree of use of specific (less general) verbs, nouns, and adjectives which are specific to the meaning being conveyed. |
| vocab.overall_metrics.academic_language_use | The degree of use of academic language in the response. |
| vocab.overall_metrics.collocation_commonality | The degree of use of advanced word combinations. |
| vocab.overall_metrics.idiomaticity | The degree of use of idiomatic language. |
| coherence.overall_metrics.lexical_density | The degree of use of content words within the response. |
| coherence.overall_metrics.basic_connectives | The degree and variety of basic connectives within the response. A list of most overused basic connectives is included. |
| coherence.overall_metrics.causal_connectives | The degree and variety of causal connectives within the response. A list of most overused causal connectives is included. |
| coherence.overall_metrics.negative_connectives | The degree and variety of negative connectives within the response. A list of most used negative connectives is included. |
| coherence.overall_metrics.pronoun_density | The degree of use of pronouns within the response. |
| coherence.overall_metrics.adverb_diversity | The degree and variety of adverbs within the response. A list of most overused adverbs is included. |
| coherence.overall_metrics.verb_diversity | The degree and variety of verbs within the response. A list of most overused verbs is included. |

An example grammar feedback looks like the following:

``` json
{   
"grammar": 
  {
    "overall_metrics": {
      "length": {
         "score": 4,
         "level": "mid"
       },
       "lexical_diversity": {
          "score": 8,
          "level": "high"
       },
       "grammatical_accuracy": {
           "score": 8,
           "level": "high"
        },
        "grammatical_range": {
            "score": 5,
            "level": "mid",
            "message": "Your response has less grammatical range than most advanced speakers. To improve, you should use a wider range of phrasal and clausal structures and verb-argument constructions.",
            "noun_phrase_complexity": {
               "score": 1,
               "level": "low",
               "message": "Your response lacks noun phrase complexity. You should use richer modifiers in noun phrases by using adjectives, relative clauses, prepositional phrases, non-finite elements, determiners, and demonstratives."
            },
            "noun_phrase_variation": {
                "score": 5,
                "level": "mid"
            },
            "verb_construction_variation": {
                "score": 6,
                "level": "mid"
             },
             "adverb_modifier_variation": {
                 "score": 9,
                 "level": "high"
              }
         }
     },
     "errors": [
      {
         "category": "STYLE",
         "message": "Did you mean 'different from'? 'Different than' is often considered colloquial style.",
         "span": [44,48],
         "matched_text": "than",
         "replacements": ["from"]
      }
     ]
 }
}

 ```

### Grammatical Errors

The `grammar.errors` node contains a JSON array of grammatical errors found in the response. Each array element is an object with the following properties:

| **key** | **Description** |
| --- | --- |
| category | The type of error such as; STYLE, GRAMMAR, COLLOCATION, CONFUSED_WORDS |
| message | A descriptive message of the error. The message may refer to words within the evalauted text and include suggested replacements within the ... markup tags. |
| span | The \[begin, end\] indices of the matched text in characters. |
| matched_text | The matched text where the error was found. |
| replacements | An array of zero or more suggested replacements where applicable. |

   * @param optionalParams - Optional parameters
   * @param optionalParams.key - API key issued by Speechace.
   * @param optionalParams.userId - A unique anonymized identifier for the end-user who spoke the audio.
   * @param optionalParams.dialect - Optional: The dialect to use for scoring. Supported values are "en-us" (US English) and "en-gb" (UK English).
   * @returns {Promise<GetGrammarVocabCoherenceFeedbackMetricsResponse>} - The promise with the result
   */
  async getGrammarVocabCoherenceFeedbackMetrics(
    input: GetGrammarVocabCoherenceFeedbackMetricsRequest,
    optionalParams: { key?: string; userId?: string; dialect?: string } = {},
  ): Promise<GetGrammarVocabCoherenceFeedbackMetricsResponse> {
    const { key, userId, dialect } = optionalParams;

    const queryParams: string[] = [];
    const headers: { [key: string]: string } = { 'Content-Type': 'multipart/form-data' };
    if (key) {
      queryParams.push(serializeQuery('form', true, 'key', key));
    }
    if (userId) {
      queryParams.push(serializeQuery('form', true, 'user_id', userId));
    }
    if (dialect) {
      queryParams.push(serializeQuery('form', true, 'dialect', dialect));
    }
    const urlEndpoint = '/api/scoring/speech/v9/json';
    const urlParams = queryParams.length > 0 ? `?${queryParams.join('&')}` : '';
    const finalUrl = encodeURI(`${this.baseUrl + urlEndpoint}${urlParams}`);
    const formInput = V9LatestService.formData(input);
    const response: any = await this.httpClient.post(
      finalUrl,
      formInput,
      {
        ...headers,
      },
      true,
    );
    const responseModel = response.data as GetGrammarVocabCoherenceFeedbackMetricsResponse;
    return responseModel;
  }
}
