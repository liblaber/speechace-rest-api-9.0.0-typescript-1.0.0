// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';
import { adverbDiversity, adverbDiversityRequest, adverbDiversityResponse } from './adverb-diversity';
import { basicConnectives, basicConnectivesRequest, basicConnectivesResponse } from './basic-connectives';
import { causalConnectives, causalConnectivesRequest, causalConnectivesResponse } from './causal-connectives';
import { lexicalDensity, lexicalDensityRequest, lexicalDensityResponse } from './lexical-density';
import { negativeConnectives, negativeConnectivesRequest, negativeConnectivesResponse } from './negative-connectives';
import { pronounDensity, pronounDensityRequest, pronounDensityResponse } from './pronoun-density';
import { verbDiversity, verbDiversityRequest, verbDiversityResponse } from './verb-diversity';

/**
 * The shape of the model inside the application code - what the users use
 */
export const coherenceOverallMetrics = z.lazy(() => {
  return z.object({
    adverbDiversity: adverbDiversity.optional(),
    basicConnectives: basicConnectives.optional(),
    causalConnectives: causalConnectives.optional(),
    lexicalDensity: lexicalDensity.optional(),
    negativeConnectives: negativeConnectives.optional(),
    pronounDensity: pronounDensity.optional(),
    verbDiversity: verbDiversity.optional(),
  });
});

/**
 *
 * @typedef  {CoherenceOverallMetrics} coherenceOverallMetrics
 * @property {AdverbDiversity}
 * @property {BasicConnectives}
 * @property {CausalConnectives}
 * @property {LexicalDensity}
 * @property {NegativeConnectives}
 * @property {PronounDensity}
 * @property {VerbDiversity}
 */
export type CoherenceOverallMetrics = z.infer<typeof coherenceOverallMetrics>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const coherenceOverallMetricsResponse = z.lazy(() => {
  return z
    .object({
      adverb_diversity: adverbDiversityResponse.optional(),
      basic_connectives: basicConnectivesResponse.optional(),
      causal_connectives: causalConnectivesResponse.optional(),
      lexical_density: lexicalDensityResponse.optional(),
      negative_connectives: negativeConnectivesResponse.optional(),
      pronoun_density: pronounDensityResponse.optional(),
      verb_diversity: verbDiversityResponse.optional(),
    })
    .transform((data) => ({
      adverbDiversity: data['adverb_diversity'],
      basicConnectives: data['basic_connectives'],
      causalConnectives: data['causal_connectives'],
      lexicalDensity: data['lexical_density'],
      negativeConnectives: data['negative_connectives'],
      pronounDensity: data['pronoun_density'],
      verbDiversity: data['verb_diversity'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const coherenceOverallMetricsRequest = z.lazy(() => {
  return z
    .object({
      adverbDiversity: adverbDiversityRequest.nullish(),
      basicConnectives: basicConnectivesRequest.nullish(),
      causalConnectives: causalConnectivesRequest.nullish(),
      lexicalDensity: lexicalDensityRequest.nullish(),
      negativeConnectives: negativeConnectivesRequest.nullish(),
      pronounDensity: pronounDensityRequest.nullish(),
      verbDiversity: verbDiversityRequest.nullish(),
    })
    .transform((data) => ({
      adverb_diversity: data['adverbDiversity'],
      basic_connectives: data['basicConnectives'],
      causal_connectives: data['causalConnectives'],
      lexical_density: data['lexicalDensity'],
      negative_connectives: data['negativeConnectives'],
      pronoun_density: data['pronounDensity'],
      verb_diversity: data['verbDiversity'],
    }));
});
