// This file was generated by liblab | https://liblab.com/

import { z } from 'zod';

/**
 * The shape of the model inside the application code - what the users use
 */
export const transcribeScore1Request = z.lazy(() => {
  return z.object({
    includeFluency: z.string().optional(),
    includeIeltsSubscore: z.string().optional(),
    includeUnknownWords: z.string().optional(),
    relevanceContext: z.string().optional(),
    userAudioFile: z.instanceof(ArrayBuffer).optional(),
  });
});

/**
 *
 * @typedef  {TranscribeScore1Request} transcribeScore1Request
 * @property {string} - includes fluency scoring for this request. To use this field you must have a Speechace API PRO key.
 * @property {string} - include IELTS subscores for (Vocabulary, Grammar, Coherence).
 * @property {string} - automatically identify the phonetic mapping for any unknown words such as names or locations and use that for scoring.
 * @property {string} - Question Prompt text provided to the user. When this parameter is passed, the relevance of the user audio transcript is evaluated for the given question prompt and a resulting relevance class is returned in .speech_score.relevance.class (TRUE/FALSE). A FALSE relevance class will result in .speech_score.fluency.overall_metrics.ielts_estimate and .speech_score.fluency.overall_metrics.pte_estimate to be set to the lowest possible score.
 * @property {ArrayBuffer} - file with user audio (wav, mp3, m4a, webm, ogg, aiff)
 */
export type TranscribeScore1Request = z.infer<typeof transcribeScore1Request>;

/**
 * The shape of the model mapping from the api schema into the application shape.
 * Is equal to application shape if all property names match the api schema
 */
export const transcribeScore1RequestResponse = z.lazy(() => {
  return z
    .object({
      include_fluency: z.string().optional(),
      include_ielts_subscore: z.string().optional(),
      include_unknown_words: z.string().optional(),
      relevance_context: z.string().optional(),
      user_audio_file: z.instanceof(ArrayBuffer).optional(),
    })
    .transform((data) => ({
      includeFluency: data['include_fluency'],
      includeIeltsSubscore: data['include_ielts_subscore'],
      includeUnknownWords: data['include_unknown_words'],
      relevanceContext: data['relevance_context'],
      userAudioFile: data['user_audio_file'],
    }));
});

/**
 * The shape of the model mapping from the application shape into the api schema.
 * Is equal to application shape if all property names match the api schema
 */
export const transcribeScore1RequestRequest = z.lazy(() => {
  return z
    .object({
      includeFluency: z.string().nullish(),
      includeIeltsSubscore: z.string().nullish(),
      includeUnknownWords: z.string().nullish(),
      relevanceContext: z.string().nullish(),
      userAudioFile: z.instanceof(ArrayBuffer).nullish(),
    })
    .transform((data) => ({
      include_fluency: data['includeFluency'],
      include_ielts_subscore: data['includeIeltsSubscore'],
      include_unknown_words: data['includeUnknownWords'],
      relevance_context: data['relevanceContext'],
      user_audio_file: data['userAudioFile'],
    }));
});
